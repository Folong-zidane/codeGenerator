package com.basiccode.generator.generator;

import com.basiccode.generator.model.*;
import com.squareup.javapoet.*;
import javax.lang.model.element.Modifier;
import java.util.UUID;
import java.time.Instant;

public class EntityGenerator {
    
    public JavaFile generateEntity(ClassModel model, String basePackage, String language) {
        switch (language.toLowerCase()) {
            case "java":
                return generateJavaEntity(model, basePackage);
            case "python":
                return generatePythonEntity(model, basePackage);
            case "csharp":
                return generateCSharpEntity(model, basePackage);
            default:
                return generateJavaEntity(model, basePackage);
        }
    }
    
    private JavaFile generateJavaEntity(ClassModel model, String basePackage) {
        // Build class with JPA annotations
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(model.getName())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(ClassName.get("jakarta.persistence", "Entity"))
            .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Table"))
                .addMember("name", "$S", toSnakeCase(model.getName()))
                .build());
        
        // Add ID field
        FieldSpec idField = FieldSpec.builder(UUID.class, "id", Modifier.PRIVATE)
            .addAnnotation(ClassName.get("jakarta.persistence", "Id"))
            .addAnnotation(ClassName.get("jakarta.persistence", "GeneratedValue"))
            .build();
        classBuilder.addField(idField);
        
        // Add fields from model
        for (Field field : model.getFields()) {
            FieldSpec fieldSpec = generateJavaField(field);
            classBuilder.addField(fieldSpec);
        }
        
        // Add audit fields
        classBuilder.addField(FieldSpec.builder(Instant.class, "createdAt", Modifier.PRIVATE)
            .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                .addMember("name", "$S", "created_at")
                .addMember("nullable", "false")
                .addMember("updatable", "false")
                .build())
            .build());
        
        classBuilder.addField(FieldSpec.builder(Instant.class, "updatedAt", Modifier.PRIVATE)
            .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                .addMember("name", "$S", "updated_at")
                .build())
            .build());
        
        // Add constructor
        classBuilder.addMethod(MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this.createdAt = $T.now()", Instant.class)
            .build());
        
        // Add getters/setters
        classBuilder.addMethod(generateGetter("id", ClassName.get(UUID.class)));
        for (Field field : model.getFields()) {
            classBuilder.addMethod(generateGetter(field.getName(), getJavaType(field.getType())));
            classBuilder.addMethod(generateSetter(field.getName(), getJavaType(field.getType())));
        }
        
        // Add methods from model
        for (Method method : model.getMethods()) {
            classBuilder.addMethod(generateJavaMethod(method));
        }
        
        // Build and create file
        TypeSpec typeSpec = classBuilder.build();
        return JavaFile.builder(basePackage + ".entity", typeSpec)
            .addFileComment("Generated by UML-to-Code Generator")
            .indent("    ")
            .build();
    }
    
    private JavaFile generatePythonEntity(ClassModel model, String basePackage) {
        // For Python, we'll generate a simple class structure
        // This is a simplified version - in a real implementation, 
        // you'd use a different approach for Python code generation
        StringBuilder pythonCode = new StringBuilder();
        pythonCode.append("from sqlalchemy import Column, String, DateTime, UUID\n");
        pythonCode.append("from sqlalchemy.ext.declarative import declarative_base\n");
        pythonCode.append("from datetime import datetime\n\n");
        pythonCode.append("Base = declarative_base()\n\n");
        pythonCode.append("class ").append(model.getName()).append("(Base):\n");
        pythonCode.append("    __tablename__ = '").append(toSnakeCase(model.getName())).append("'\n\n");
        pythonCode.append("    id = Column(UUID, primary_key=True)\n");
        
        for (Field field : model.getFields()) {
            pythonCode.append("    ").append(field.getName())
                     .append(" = Column(").append(getPythonType(field.getType())).append(")\n");
        }
        
        pythonCode.append("    created_at = Column(DateTime, default=datetime.utcnow)\n");
        pythonCode.append("    updated_at = Column(DateTime, onupdate=datetime.utcnow)\n");
        
        // Return as JavaFile for consistency (in real implementation, use appropriate Python generator)
        TypeSpec dummyClass = TypeSpec.classBuilder("PythonCode")
            .addJavadoc(pythonCode.toString())
            .build();
        
        return JavaFile.builder(basePackage, dummyClass).build();
    }
    
    private JavaFile generateCSharpEntity(ClassModel model, String basePackage) {
        // Similar approach for C# - simplified version
        StringBuilder csharpCode = new StringBuilder();
        csharpCode.append("using System;\n");
        csharpCode.append("using System.ComponentModel.DataAnnotations;\n");
        csharpCode.append("using System.ComponentModel.DataAnnotations.Schema;\n\n");
        csharpCode.append("namespace ").append(basePackage).append(".Entities\n{\n");
        csharpCode.append("    [Table(\"").append(toSnakeCase(model.getName())).append("\")]\n");
        csharpCode.append("    public class ").append(model.getName()).append("\n    {\n");
        csharpCode.append("        [Key]\n");
        csharpCode.append("        public Guid Id { get; set; }\n\n");
        
        for (Field field : model.getFields()) {
            csharpCode.append("        public ").append(getCSharpType(field.getType()))
                     .append(" ").append(capitalize(field.getName())).append(" { get; set; }\n");
        }
        
        csharpCode.append("        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n");
        csharpCode.append("        public DateTime? UpdatedAt { get; set; }\n");
        csharpCode.append("    }\n}");
        
        TypeSpec dummyClass = TypeSpec.classBuilder("CSharpCode")
            .addJavadoc(csharpCode.toString())
            .build();
        
        return JavaFile.builder(basePackage, dummyClass).build();
    }
    
    private FieldSpec generateJavaField(Field field) {
        FieldSpec.Builder builder = FieldSpec.builder(
            getJavaType(field.getType()),
            field.getName(),
            field.getVisibility().toModifier()
        );
        
        // Add JPA annotations based on type
        if (field.getType().equals("String")) {
            AnnotationSpec.Builder columnBuilder = AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"));
            if (!field.isNullable()) {
                columnBuilder.addMember("nullable", "false");
            }
            if (field.isUnique()) {
                columnBuilder.addMember("unique", "true");
            }
            builder.addAnnotation(columnBuilder.build());
        }
        
        return builder.build();
    }
    
    private MethodSpec generateGetter(String fieldName, TypeName type) {
        String methodName = "get" + capitalize(fieldName);
        return MethodSpec.methodBuilder(methodName)
            .addModifiers(Modifier.PUBLIC)
            .returns(type)
            .addStatement("return this.$N", fieldName)
            .build();
    }
    
    private MethodSpec generateSetter(String fieldName, TypeName type) {
        String methodName = "set" + capitalize(fieldName);
        return MethodSpec.methodBuilder(methodName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(type, fieldName)
            .addStatement("this.$N = $N", fieldName, fieldName)
            .addStatement("this.updatedAt = $T.now()", Instant.class)
            .build();
    }
    
    private MethodSpec generateJavaMethod(Method method) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder(method.getName())
            .addModifiers(method.getVisibility().toModifier())
            .returns(getJavaType(method.getReturnType()));
        
        for (Parameter param : method.getParameters()) {
            builder.addParameter(getJavaType(param.getType()), param.getName());
        }
        
        if (!method.getReturnType().equals("void")) {
            builder.addStatement("// TODO: Implement business logic");
            builder.addStatement("return null");
        } else {
            builder.addStatement("// TODO: Implement business logic");
        }
        
        return builder.build();
    }
    
    private TypeName getJavaType(String type) {
        return switch (type) {
            case "String" -> ClassName.get(String.class);
            case "Integer", "int" -> ClassName.get(Integer.class);
            case "Long", "long" -> ClassName.get(Long.class);
            case "Float", "float" -> ClassName.get(Float.class);
            case "Double", "double" -> ClassName.get(Double.class);
            case "Boolean", "boolean" -> ClassName.get(Boolean.class);
            case "UUID" -> ClassName.get(UUID.class);
            case "Instant", "Date" -> ClassName.get(Instant.class);
            case "void" -> TypeName.VOID;
            default -> ClassName.bestGuess(type);
        };
    }
    
    private String getPythonType(String type) {
        return switch (type) {
            case "String" -> "String";
            case "Integer", "int" -> "Integer";
            case "Long", "long" -> "BigInteger";
            case "Float", "float" -> "Float";
            case "Double", "double" -> "Float";
            case "Boolean", "boolean" -> "Boolean";
            case "UUID" -> "UUID";
            case "Instant", "Date" -> "DateTime";
            default -> "String";
        };
    }
    
    private String getCSharpType(String type) {
        return switch (type) {
            case "String" -> "string";
            case "Integer", "int" -> "int";
            case "Long", "long" -> "long";
            case "Float", "float" -> "float";
            case "Double", "double" -> "double";
            case "Boolean", "boolean" -> "bool";
            case "UUID" -> "Guid";
            case "Instant", "Date" -> "DateTime";
            default -> "string";
        };
    }
    
    private String toSnakeCase(String camelCase) {
        return camelCase.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }
    
    private String capitalize(String str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}