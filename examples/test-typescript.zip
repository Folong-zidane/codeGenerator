{"files":{"controllers/UserController.java":"import { Request, Response } from 'express';\nimport { UserService, IUserService } from '../services/UserService';\n\nexport class UserController {\n  private service: IUserService;\n\n  constructor() {\n    this.service = new UserService();\n  }\n\n  /**\n   * Get all users\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get user by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new user\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update user by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete user by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'User not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend user by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendUser(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate user by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateUser(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","services/UserService.java":"import { User } from '../entities/User';\nimport { UserRepository, IUserRepository } from '../repositories/UserRepository';\n\nexport interface IUserService {\n  getAll(): Promise<User[]>;\n  getById(id: number): Promise<User | null>;\n  create(data: Partial<User>): Promise<User>;\n  update(id: number, data: Partial<User>): Promise<User | null>;\n  delete(id: number): Promise<void>;\n  suspendUser(id: number): Promise<User | null>;\n  activateUser(id: number): Promise<User | null>;\n}\n\nexport class UserService implements IUserService {\n  private repository: IUserRepository;\n\n  constructor() {\n    this.repository = new UserRepository();\n  }\n\n  async getAll(): Promise<User[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<User | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<User>): Promise<User> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<User>): Promise<User | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendUser(id: number): Promise<User | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateUser(id: number): Promise<User | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<User>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","config/V001__Initial_Schema.sql":"import 'reflect-metadata';\nimport { DataSource } from 'typeorm';\nimport { User } from './entities/User';\n\nexport const AppDataSource = new DataSource({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USERNAME || 'postgres',\n  password: process.env.DB_PASSWORD || 'password',\n  database: process.env.DB_NAME || 'com.example.typescript',\n  synchronize: process.env.NODE_ENV === 'development',\n  logging: process.env.NODE_ENV === 'development',\n  entities: [User],\n  migrations: ['src/migrations/*.ts'],\n  subscribers: ['src/subscribers/*.ts'],\n});\n\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { AppDataSource } from './data-source';\nimport { setupRoutes } from './routes';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\nsetupRoutes(app);\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Error handling\napp.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Start server\nAppDataSource.initialize()\n  .then(() => {\n    console.log('\uD83D\uDCCA Database connected successfully');\n    \n    app.listen(PORT, () => {\n      console.log(`\uD83D\uDE80 Server running on port ${PORT}`);\n      console.log(`\uD83D\uDCD6 API documentation: http://localhost:${PORT}/api`);\n    });\n  })\n  .catch((error) => {\n    console.error('❌ Database connection failed:', error);\n    process.exit(1);\n  });\n\nexport default app;\n\n\nimport { Express, Router } from 'express';\nimport { UserController } from './controllers/UserController';\n\nexport function setupRoutes(app: Express): void {\n  const apiRouter = Router();\n\n  // User routes\n  const userController = new UserController();\n  const userRouter = Router();\n  userRouter.get('/', userController.getAll);\n  userRouter.get('/:id', userController.getById);\n  userRouter.post('/', userController.create);\n  userRouter.put('/:id', userController.update);\n  userRouter.delete('/:id', userController.delete);\n  userRouter.patch('/:id/suspend', userController.suspend);\n  userRouter.patch('/:id/activate', userController.activate);\n  apiRouter.use('/users', userRouter);\n\n  app.use('/api', apiRouter);\n}\n","repositories/UserRepository.java":"import { Repository } from 'typeorm';\nimport { User } from '../entities/User';\nimport { AppDataSource } from '../data-source';\n\nexport interface IUserRepository {\n  findAll(): Promise<User[]>;\n  findById(id: number): Promise<User | null>;\n  create(entity: Partial<User>): Promise<User>;\n  update(id: number, entity: Partial<User>): Promise<User | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class UserRepository implements IUserRepository {\n  private repository: Repository<User>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(User);\n  }\n\n  async findAll(): Promise<User[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<User | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<User>): Promise<User> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<User>): Promise<User | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","entities/User.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { UserStatus } from '../enums/UserStatus';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: string;\n\n  @Column()\n  username: string;\n\n  @Column()\n  email: string;\n\n  @Column()\n  status: string;\n\n  @Column({ type: 'enum', enum: UserStatus })\n  status: UserStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== UserStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = UserStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== UserStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = UserStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","enums/UserStatus.ts":"export enum UserStatus {\n  ACTIVE = 'ACTIVE',\n  SUSPENDED = 'SUSPENDED'\n}\n","README.md":"# Generated Application\n\nThis application was generated from UML diagrams using the modular code generator.\n\n## Architecture\n\n- **Entities**: Domain models with state management\n- **Repositories**: Data access layer\n- **Services**: Business logic layer\n- **Controllers**: REST API endpoints\n\n## Generated Classes\n\n### User\n- **Stateful entity** with state transitions\n\n"},"packageName":null,"language":null,"generatedFiles":{"controllers/UserController.java":"import { Request, Response } from 'express';\nimport { UserService, IUserService } from '../services/UserService';\n\nexport class UserController {\n  private service: IUserService;\n\n  constructor() {\n    this.service = new UserService();\n  }\n\n  /**\n   * Get all users\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get user by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new user\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update user by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete user by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'User not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend user by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendUser(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate user by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateUser(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'User not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","services/UserService.java":"import { User } from '../entities/User';\nimport { UserRepository, IUserRepository } from '../repositories/UserRepository';\n\nexport interface IUserService {\n  getAll(): Promise<User[]>;\n  getById(id: number): Promise<User | null>;\n  create(data: Partial<User>): Promise<User>;\n  update(id: number, data: Partial<User>): Promise<User | null>;\n  delete(id: number): Promise<void>;\n  suspendUser(id: number): Promise<User | null>;\n  activateUser(id: number): Promise<User | null>;\n}\n\nexport class UserService implements IUserService {\n  private repository: IUserRepository;\n\n  constructor() {\n    this.repository = new UserRepository();\n  }\n\n  async getAll(): Promise<User[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<User | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<User>): Promise<User> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<User>): Promise<User | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendUser(id: number): Promise<User | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateUser(id: number): Promise<User | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`User with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<User>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","config/V001__Initial_Schema.sql":"import 'reflect-metadata';\nimport { DataSource } from 'typeorm';\nimport { User } from './entities/User';\n\nexport const AppDataSource = new DataSource({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USERNAME || 'postgres',\n  password: process.env.DB_PASSWORD || 'password',\n  database: process.env.DB_NAME || 'com.example.typescript',\n  synchronize: process.env.NODE_ENV === 'development',\n  logging: process.env.NODE_ENV === 'development',\n  entities: [User],\n  migrations: ['src/migrations/*.ts'],\n  subscribers: ['src/subscribers/*.ts'],\n});\n\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { AppDataSource } from './data-source';\nimport { setupRoutes } from './routes';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\nsetupRoutes(app);\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Error handling\napp.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Start server\nAppDataSource.initialize()\n  .then(() => {\n    console.log('\uD83D\uDCCA Database connected successfully');\n    \n    app.listen(PORT, () => {\n      console.log(`\uD83D\uDE80 Server running on port ${PORT}`);\n      console.log(`\uD83D\uDCD6 API documentation: http://localhost:${PORT}/api`);\n    });\n  })\n  .catch((error) => {\n    console.error('❌ Database connection failed:', error);\n    process.exit(1);\n  });\n\nexport default app;\n\n\nimport { Express, Router } from 'express';\nimport { UserController } from './controllers/UserController';\n\nexport function setupRoutes(app: Express): void {\n  const apiRouter = Router();\n\n  // User routes\n  const userController = new UserController();\n  const userRouter = Router();\n  userRouter.get('/', userController.getAll);\n  userRouter.get('/:id', userController.getById);\n  userRouter.post('/', userController.create);\n  userRouter.put('/:id', userController.update);\n  userRouter.delete('/:id', userController.delete);\n  userRouter.patch('/:id/suspend', userController.suspend);\n  userRouter.patch('/:id/activate', userController.activate);\n  apiRouter.use('/users', userRouter);\n\n  app.use('/api', apiRouter);\n}\n","repositories/UserRepository.java":"import { Repository } from 'typeorm';\nimport { User } from '../entities/User';\nimport { AppDataSource } from '../data-source';\n\nexport interface IUserRepository {\n  findAll(): Promise<User[]>;\n  findById(id: number): Promise<User | null>;\n  create(entity: Partial<User>): Promise<User>;\n  update(id: number, entity: Partial<User>): Promise<User | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class UserRepository implements IUserRepository {\n  private repository: Repository<User>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(User);\n  }\n\n  async findAll(): Promise<User[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<User | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<User>): Promise<User> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<User>): Promise<User | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","entities/User.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { UserStatus } from '../enums/UserStatus';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: string;\n\n  @Column()\n  username: string;\n\n  @Column()\n  email: string;\n\n  @Column()\n  status: string;\n\n  @Column({ type: 'enum', enum: UserStatus })\n  status: UserStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== UserStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = UserStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== UserStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = UserStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","enums/UserStatus.ts":"export enum UserStatus {\n  ACTIVE = 'ACTIVE',\n  SUSPENDED = 'SUSPENDED'\n}\n","README.md":"# Generated Application\n\nThis application was generated from UML diagrams using the modular code generator.\n\n## Architecture\n\n- **Entities**: Domain models with state management\n- **Repositories**: Data access layer\n- **Services**: Business logic layer\n- **Controllers**: REST API endpoints\n\n## Generated Classes\n\n### User\n- **Stateful entity** with state transitions\n\n"}}