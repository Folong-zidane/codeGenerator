{"files":{"enums/OrderStatus.ts":"export enum OrderStatus {\n  DELIVERED = 'DELIVERED',\n  CONFIRMED = 'CONFIRMED',\n  INITIAL = 'INITIAL',\n  PENDING = 'PENDING',\n  SHIPPED = 'SHIPPED'\n}\n","services/ProductService.java":"import { Product } from '../entities/Product';\nimport { ProductRepository, IProductRepository } from '../repositories/ProductRepository';\n\nexport interface IProductService {\n  getAll(): Promise<Product[]>;\n  getById(id: number): Promise<Product | null>;\n  create(data: Partial<Product>): Promise<Product>;\n  update(id: number, data: Partial<Product>): Promise<Product | null>;\n  delete(id: number): Promise<void>;\n  suspendProduct(id: number): Promise<Product | null>;\n  activateProduct(id: number): Promise<Product | null>;\n}\n\nexport class ProductService implements IProductService {\n  private repository: IProductRepository;\n\n  constructor() {\n    this.repository = new ProductRepository();\n  }\n\n  async getAll(): Promise<Product[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<Product | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<Product>): Promise<Product> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<Product>): Promise<Product | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendProduct(id: number): Promise<Product | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateProduct(id: number): Promise<Product | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<Product>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","repositories/OrderRepository.java":"import { Repository } from 'typeorm';\nimport { Order } from '../entities/Order';\nimport { AppDataSource } from '../data-source';\n\nexport interface IOrderRepository {\n  findAll(): Promise<Order[]>;\n  findById(id: number): Promise<Order | null>;\n  create(entity: Partial<Order>): Promise<Order>;\n  update(id: number, entity: Partial<Order>): Promise<Order | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class OrderRepository implements IOrderRepository {\n  private repository: Repository<Order>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(Order);\n  }\n\n  async findAll(): Promise<Order[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<Order | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<Order>): Promise<Order> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<Order>): Promise<Order | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","entities/Order.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { OrderStatus } from '../enums/OrderStatus';\n\n@Entity('orders')\nexport class Order {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  productId: number;\n\n  @Column()\n  quantity: number;\n\n  @Column({ type: 'enum', enum: OrderStatus })\n  status: OrderStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== OrderStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = OrderStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== OrderStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = OrderStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","enums/ProductStatus.ts":"export enum ProductStatus {\n  DELIVERED = 'DELIVERED',\n  CONFIRMED = 'CONFIRMED',\n  INITIAL = 'INITIAL',\n  PENDING = 'PENDING',\n  SHIPPED = 'SHIPPED'\n}\n","config/V001__Initial_Schema.sql":"import 'reflect-metadata';\nimport { DataSource } from 'typeorm';\nimport { Product } from './entities/Product';\nimport { Order } from './entities/Order';\n\nexport const AppDataSource = new DataSource({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USERNAME || 'postgres',\n  password: process.env.DB_PASSWORD || 'password',\n  database: process.env.DB_NAME || 'ecommerce_api',\n  synchronize: process.env.NODE_ENV === 'development',\n  logging: process.env.NODE_ENV === 'development',\n  entities: [Product, Order],\n  migrations: ['src/migrations/*.ts'],\n  subscribers: ['src/subscribers/*.ts'],\n});\n\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { AppDataSource } from './data-source';\nimport { setupRoutes } from './routes';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\nsetupRoutes(app);\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Error handling\napp.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Start server\nAppDataSource.initialize()\n  .then(() => {\n    console.log('\uD83D\uDCCA Database connected successfully');\n    \n    app.listen(PORT, () => {\n      console.log(`\uD83D\uDE80 Server running on port ${PORT}`);\n      console.log(`\uD83D\uDCD6 API documentation: http://localhost:${PORT}/api`);\n    });\n  })\n  .catch((error) => {\n    console.error('❌ Database connection failed:', error);\n    process.exit(1);\n  });\n\nexport default app;\n\n\nimport { Express, Router } from 'express';\nimport { ProductController } from './controllers/ProductController';\nimport { OrderController } from './controllers/OrderController';\n\nexport function setupRoutes(app: Express): void {\n  const apiRouter = Router();\n\n  // Product routes\n  const productController = new ProductController();\n  const productRouter = Router();\n  productRouter.get('/', productController.getAll);\n  productRouter.get('/:id', productController.getById);\n  productRouter.post('/', productController.create);\n  productRouter.put('/:id', productController.update);\n  productRouter.delete('/:id', productController.delete);\n  productRouter.patch('/:id/suspend', productController.suspend);\n  productRouter.patch('/:id/activate', productController.activate);\n  apiRouter.use('/products', productRouter);\n\n  // Order routes\n  const orderController = new OrderController();\n  const orderRouter = Router();\n  orderRouter.get('/', orderController.getAll);\n  orderRouter.get('/:id', orderController.getById);\n  orderRouter.post('/', orderController.create);\n  orderRouter.put('/:id', orderController.update);\n  orderRouter.delete('/:id', orderController.delete);\n  orderRouter.patch('/:id/suspend', orderController.suspend);\n  orderRouter.patch('/:id/activate', orderController.activate);\n  apiRouter.use('/orders', orderRouter);\n\n  app.use('/api', apiRouter);\n}\n","services/OrderService.java":"import { Order } from '../entities/Order';\nimport { OrderRepository, IOrderRepository } from '../repositories/OrderRepository';\n\nexport interface IOrderService {\n  getAll(): Promise<Order[]>;\n  getById(id: number): Promise<Order | null>;\n  create(data: Partial<Order>): Promise<Order>;\n  update(id: number, data: Partial<Order>): Promise<Order | null>;\n  delete(id: number): Promise<void>;\n  suspendOrder(id: number): Promise<Order | null>;\n  activateOrder(id: number): Promise<Order | null>;\n}\n\nexport class OrderService implements IOrderService {\n  private repository: IOrderRepository;\n\n  constructor() {\n    this.repository = new OrderRepository();\n  }\n\n  async getAll(): Promise<Order[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<Order | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<Order>): Promise<Order> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<Order>): Promise<Order | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendOrder(id: number): Promise<Order | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateOrder(id: number): Promise<Order | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<Order>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","entities/Product.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { ProductStatus } from '../enums/ProductStatus';\n\n@Entity('products')\nexport class Product {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  price: number;\n\n  @Column({ type: 'enum', enum: ProductStatus })\n  status: ProductStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== ProductStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = ProductStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== ProductStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = ProductStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","repositories/ProductRepository.java":"import { Repository } from 'typeorm';\nimport { Product } from '../entities/Product';\nimport { AppDataSource } from '../data-source';\n\nexport interface IProductRepository {\n  findAll(): Promise<Product[]>;\n  findById(id: number): Promise<Product | null>;\n  create(entity: Partial<Product>): Promise<Product>;\n  update(id: number, entity: Partial<Product>): Promise<Product | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class ProductRepository implements IProductRepository {\n  private repository: Repository<Product>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(Product);\n  }\n\n  async findAll(): Promise<Product[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<Product | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<Product>): Promise<Product> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<Product>): Promise<Product | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","controllers/ProductController.java":"import { Request, Response } from 'express';\nimport { ProductService, IProductService } from '../services/ProductService';\n\nexport class ProductController {\n  private service: IProductService;\n\n  constructor() {\n    this.service = new ProductService();\n  }\n\n  /**\n   * Get all products\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get product by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new product\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update product by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete product by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'Product not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend product by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendProduct(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate product by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateProduct(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","controllers/OrderController.java":"import { Request, Response } from 'express';\nimport { OrderService, IOrderService } from '../services/OrderService';\n\nexport class OrderController {\n  private service: IOrderService;\n\n  constructor() {\n    this.service = new OrderService();\n  }\n\n  /**\n   * Get all orders\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get order by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new order\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update order by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete order by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'Order not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend order by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendOrder(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate order by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateOrder(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","README.md":"# Generated Application\n\nThis application was generated from UML diagrams using the modular code generator.\n\n## Architecture\n\n- **Entities**: Domain models with state management\n- **Repositories**: Data access layer\n- **Services**: Business logic layer\n- **Controllers**: REST API endpoints\n\n## Generated Classes\n\n### Product\n- **Stateful entity** with state transitions\n\n### Order\n- **Stateful entity** with state transitions\n\n"},"packageName":null,"language":null,"generatedFiles":{"enums/OrderStatus.ts":"export enum OrderStatus {\n  DELIVERED = 'DELIVERED',\n  CONFIRMED = 'CONFIRMED',\n  INITIAL = 'INITIAL',\n  PENDING = 'PENDING',\n  SHIPPED = 'SHIPPED'\n}\n","services/ProductService.java":"import { Product } from '../entities/Product';\nimport { ProductRepository, IProductRepository } from '../repositories/ProductRepository';\n\nexport interface IProductService {\n  getAll(): Promise<Product[]>;\n  getById(id: number): Promise<Product | null>;\n  create(data: Partial<Product>): Promise<Product>;\n  update(id: number, data: Partial<Product>): Promise<Product | null>;\n  delete(id: number): Promise<void>;\n  suspendProduct(id: number): Promise<Product | null>;\n  activateProduct(id: number): Promise<Product | null>;\n}\n\nexport class ProductService implements IProductService {\n  private repository: IProductRepository;\n\n  constructor() {\n    this.repository = new ProductRepository();\n  }\n\n  async getAll(): Promise<Product[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<Product | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<Product>): Promise<Product> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<Product>): Promise<Product | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendProduct(id: number): Promise<Product | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateProduct(id: number): Promise<Product | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Product with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<Product>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","repositories/OrderRepository.java":"import { Repository } from 'typeorm';\nimport { Order } from '../entities/Order';\nimport { AppDataSource } from '../data-source';\n\nexport interface IOrderRepository {\n  findAll(): Promise<Order[]>;\n  findById(id: number): Promise<Order | null>;\n  create(entity: Partial<Order>): Promise<Order>;\n  update(id: number, entity: Partial<Order>): Promise<Order | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class OrderRepository implements IOrderRepository {\n  private repository: Repository<Order>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(Order);\n  }\n\n  async findAll(): Promise<Order[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<Order | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<Order>): Promise<Order> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<Order>): Promise<Order | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","entities/Order.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { OrderStatus } from '../enums/OrderStatus';\n\n@Entity('orders')\nexport class Order {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  productId: number;\n\n  @Column()\n  quantity: number;\n\n  @Column({ type: 'enum', enum: OrderStatus })\n  status: OrderStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== OrderStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = OrderStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== OrderStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = OrderStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","enums/ProductStatus.ts":"export enum ProductStatus {\n  DELIVERED = 'DELIVERED',\n  CONFIRMED = 'CONFIRMED',\n  INITIAL = 'INITIAL',\n  PENDING = 'PENDING',\n  SHIPPED = 'SHIPPED'\n}\n","config/V001__Initial_Schema.sql":"import 'reflect-metadata';\nimport { DataSource } from 'typeorm';\nimport { Product } from './entities/Product';\nimport { Order } from './entities/Order';\n\nexport const AppDataSource = new DataSource({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USERNAME || 'postgres',\n  password: process.env.DB_PASSWORD || 'password',\n  database: process.env.DB_NAME || 'ecommerce_api',\n  synchronize: process.env.NODE_ENV === 'development',\n  logging: process.env.NODE_ENV === 'development',\n  entities: [Product, Order],\n  migrations: ['src/migrations/*.ts'],\n  subscribers: ['src/subscribers/*.ts'],\n});\n\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { AppDataSource } from './data-source';\nimport { setupRoutes } from './routes';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\nsetupRoutes(app);\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'OK', timestamp: new Date().toISOString() });\n});\n\n// Error handling\napp.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Start server\nAppDataSource.initialize()\n  .then(() => {\n    console.log('\uD83D\uDCCA Database connected successfully');\n    \n    app.listen(PORT, () => {\n      console.log(`\uD83D\uDE80 Server running on port ${PORT}`);\n      console.log(`\uD83D\uDCD6 API documentation: http://localhost:${PORT}/api`);\n    });\n  })\n  .catch((error) => {\n    console.error('❌ Database connection failed:', error);\n    process.exit(1);\n  });\n\nexport default app;\n\n\nimport { Express, Router } from 'express';\nimport { ProductController } from './controllers/ProductController';\nimport { OrderController } from './controllers/OrderController';\n\nexport function setupRoutes(app: Express): void {\n  const apiRouter = Router();\n\n  // Product routes\n  const productController = new ProductController();\n  const productRouter = Router();\n  productRouter.get('/', productController.getAll);\n  productRouter.get('/:id', productController.getById);\n  productRouter.post('/', productController.create);\n  productRouter.put('/:id', productController.update);\n  productRouter.delete('/:id', productController.delete);\n  productRouter.patch('/:id/suspend', productController.suspend);\n  productRouter.patch('/:id/activate', productController.activate);\n  apiRouter.use('/products', productRouter);\n\n  // Order routes\n  const orderController = new OrderController();\n  const orderRouter = Router();\n  orderRouter.get('/', orderController.getAll);\n  orderRouter.get('/:id', orderController.getById);\n  orderRouter.post('/', orderController.create);\n  orderRouter.put('/:id', orderController.update);\n  orderRouter.delete('/:id', orderController.delete);\n  orderRouter.patch('/:id/suspend', orderController.suspend);\n  orderRouter.patch('/:id/activate', orderController.activate);\n  apiRouter.use('/orders', orderRouter);\n\n  app.use('/api', apiRouter);\n}\n","services/OrderService.java":"import { Order } from '../entities/Order';\nimport { OrderRepository, IOrderRepository } from '../repositories/OrderRepository';\n\nexport interface IOrderService {\n  getAll(): Promise<Order[]>;\n  getById(id: number): Promise<Order | null>;\n  create(data: Partial<Order>): Promise<Order>;\n  update(id: number, data: Partial<Order>): Promise<Order | null>;\n  delete(id: number): Promise<void>;\n  suspendOrder(id: number): Promise<Order | null>;\n  activateOrder(id: number): Promise<Order | null>;\n}\n\nexport class OrderService implements IOrderService {\n  private repository: IOrderRepository;\n\n  constructor() {\n    this.repository = new OrderRepository();\n  }\n\n  async getAll(): Promise<Order[]> {\n    return await this.repository.findAll();\n  }\n\n  async getById(id: number): Promise<Order | null> {\n    return await this.repository.findById(id);\n  }\n\n  async create(data: Partial<Order>): Promise<Order> {\n    this.validateEntity(data);\n    return await this.repository.create(data);\n  }\n\n  async update(id: number, data: Partial<Order>): Promise<Order | null> {\n    const existing = await this.repository.findById(id);\n    if (!existing) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    this.validateEntity(data);\n    return await this.repository.update(id, data);\n  }\n\n  async delete(id: number): Promise<void> {\n    const exists = await this.repository.exists(id);\n    if (!exists) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    await this.repository.delete(id);\n  }\n\n  async suspendOrder(id: number): Promise<Order | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    entity.suspend();\n    return await this.repository.update(id, entity);\n  }\n\n  async activateOrder(id: number): Promise<Order | null> {\n    const entity = await this.repository.findById(id);\n    if (!entity) {\n      throw new Error(`Order with id ${id} not found`);\n    }\n    \n    entity.activate();\n    return await this.repository.update(id, entity);\n  }\n\n  private validateEntity(data: Partial<Order>): void {\n    if (!data) {\n      throw new Error('Entity data is required');\n    }\n    // Add custom validation logic here\n  }\n}\n","entities/Product.ts":"import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { ProductStatus } from '../enums/ProductStatus';\n\n@Entity('products')\nexport class Product {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  price: number;\n\n  @Column({ type: 'enum', enum: ProductStatus })\n  status: ProductStatus;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  suspend(): void {\n    if (this.status !== ProductStatus.ACTIVE) {\n      throw new Error(`Cannot suspend entity in state: ${this.status}`);\n    }\n    this.status = ProductStatus.SUSPENDED;\n    this.updatedAt = new Date();\n  }\n\n  activate(): void {\n    if (this.status !== ProductStatus.SUSPENDED) {\n      throw new Error(`Cannot activate entity in state: ${this.status}`);\n    }\n    this.status = ProductStatus.ACTIVE;\n    this.updatedAt = new Date();\n  }\n\n}\n","repositories/ProductRepository.java":"import { Repository } from 'typeorm';\nimport { Product } from '../entities/Product';\nimport { AppDataSource } from '../data-source';\n\nexport interface IProductRepository {\n  findAll(): Promise<Product[]>;\n  findById(id: number): Promise<Product | null>;\n  create(entity: Partial<Product>): Promise<Product>;\n  update(id: number, entity: Partial<Product>): Promise<Product | null>;\n  delete(id: number): Promise<void>;\n  exists(id: number): Promise<boolean>;\n}\n\nexport class ProductRepository implements IProductRepository {\n  private repository: Repository<Product>;\n\n  constructor() {\n    this.repository = AppDataSource.getRepository(Product);\n  }\n\n  async findAll(): Promise<Product[]> {\n    return await this.repository.find();\n  }\n\n  async findById(id: number): Promise<Product | null> {\n    return await this.repository.findOne({ where: { id } });\n  }\n\n  async create(entity: Partial<Product>): Promise<Product> {\n    const newEntity = this.repository.create(entity);\n    return await this.repository.save(newEntity);\n  }\n\n  async update(id: number, entity: Partial<Product>): Promise<Product | null> {\n    await this.repository.update(id, entity);\n    return await this.findById(id);\n  }\n\n  async delete(id: number): Promise<void> {\n    await this.repository.delete(id);\n  }\n\n  async exists(id: number): Promise<boolean> {\n    const count = await this.repository.count({ where: { id } });\n    return count > 0;\n  }\n}\n","controllers/ProductController.java":"import { Request, Response } from 'express';\nimport { ProductService, IProductService } from '../services/ProductService';\n\nexport class ProductController {\n  private service: IProductService;\n\n  constructor() {\n    this.service = new ProductService();\n  }\n\n  /**\n   * Get all products\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get product by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new product\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update product by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete product by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'Product not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend product by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendProduct(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate product by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateProduct(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Product not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","controllers/OrderController.java":"import { Request, Response } from 'express';\nimport { OrderService, IOrderService } from '../services/OrderService';\n\nexport class OrderController {\n  private service: IOrderService;\n\n  constructor() {\n    this.service = new OrderService();\n  }\n\n  /**\n   * Get all orders\n   */\n  getAll = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entities = await this.service.getAll();\n      res.json(entities);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Get order by ID\n   */\n  getById = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.getById(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(500).json({ error: 'Internal server error', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Create new order\n   */\n  create = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const entity = await this.service.create(req.body);\n      res.status(201).json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Update order by ID\n   */\n  update = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.update(id, req.body);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Bad request', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Delete order by ID\n   */\n  delete = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      await this.service.delete(id);\n      res.status(204).send();\n    } catch (error) {\n      res.status(404).json({ error: 'Order not found', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Suspend order by ID\n   */\n  suspend = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.suspendOrder(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n  /**\n   * Activate order by ID\n   */\n  activate = async (req: Request, res: Response): Promise<void> => {\n    try {\n      const id = parseInt(req.params.id);\n      const entity = await this.service.activateOrder(id);\n      \n      if (!entity) {\n        res.status(404).json({ error: 'Order not found', id });\n        return;\n      }\n      \n      res.json(entity);\n    } catch (error) {\n      res.status(400).json({ error: 'Invalid state transition', message: (error as Error).message });\n    }\n  };\n\n}\n","README.md":"# Generated Application\n\nThis application was generated from UML diagrams using the modular code generator.\n\n## Architecture\n\n- **Entities**: Domain models with state management\n- **Repositories**: Data access layer\n- **Services**: Business logic layer\n- **Controllers**: REST API endpoints\n\n## Generated Classes\n\n### Product\n- **Stateful entity** with state transitions\n\n### Order\n- **Stateful entity** with state transitions\n\n"}}